// AUTHOR: MYLES BUSIG
// CONTRIBUTORS: N/A

class EntityEnemy : ZilchComponent
{
    [Property] var AttackCooldown : Real = 1.0;
    [Property] var CanShoot : Boolean = true;
    [Property] var CanAttackForward : Boolean = true;
    [Property] var AttackDamage : Real = 2.0;
    [Property] var AttackWithinRadiusOf : Real = 4.0;
    [Property] var HitboxSize : Real = 1.0;
    [Property] var HitboxLifetime : Real = 3.0;
    [Property] var CanMove : Boolean = true;
    var TimeTillAttack : Real = 0.0;
    var Player : Cog = null;
    
    [Property] var LookUp : SpriteSource;
    [Property] var LookUpRight : SpriteSource;
    [Property] var LookRight : SpriteSource;
    [Property] var LookDownRight : SpriteSource;
    [Property] var LookDown : SpriteSource;
    [Property] var LookDownLeft : SpriteSource;
    [Property] var LookLeft : SpriteSource;
    [Property] var LookUpLeft : SpriteSource;
    
    function Initialize(init : CogInitializer)
    {
        // Find player
        this.Player = this.Space.FindObjectByName("EntityPlayer");
        
        Zero.Connect(this.Space, Events.LogicUpdate, this.OnLogicUpdate);
    }

    function OnLogicUpdate(event : UpdateEvent)
    {
        // Check for player
        if (this.CheckForPlayer() == false)
            return;
        
        // Change "EnemySprite"
        this.ChangeSprite();
        
        // Decrease "TimeTillAttack"
        this.TimeTillAttack -= event.Dt;
        
        // Look at the player
        this.LookAtPlayer();
        
        // Attack
        if (this.CanAttackForward == true && this.CanShoot == true && this.TimeTillAttack <= 0.0)
        {
            var differance = this.Player.Transform.Translation - this.Owner.Transform.Translation;
            
            if (differance.X < -2.5 || differance.X > 2.5 || differance.Y < -2.5 || differance.Y > 2.5)
                this.Shoot();
            else
                this.AttackBasedOnRadius();
        }
        else if (this.CanAttackForward == true && this.TimeTillAttack <= 0.0)
            this.AttackBasedOnRadius();
        else if (this.CanShoot == true && this.TimeTillAttack <= 0.0)
            this.Shoot();
    }
    
    function AttackBasedOnRadius()
    {
        // If the player is within the attack radius
        if (this.Player.Transform.Translation.X <= this.Owner.Transform.Translation.X + this.AttackWithinRadiusOf &&
            this.Player.Transform.Translation.X >= this.Owner.Transform.Translation.X - this.AttackWithinRadiusOf &&
            this.Player.Transform.Translation.Y <= this.Owner.Transform.Translation.Y + this.AttackWithinRadiusOf &&
            this.Player.Transform.Translation.Y >= this.Owner.Transform.Translation.Y - this.AttackWithinRadiusOf)
        {
            // Reset the attack timer
            this.TimeTillAttack = this.AttackCooldown;
            
            // Create hitbox
            var hitbox = this.Space.CreateAtPosition(Archetype.HitBox, this.Owner.Transform.Translation + this.Owner.Orientation.WorldForward);
            hitbox.Orientation.LookAtDirection(this.Owner.Orientation.WorldForward);
            hitbox.BoxCollider.Size = Real3(1.0, this.HitboxSize, 1.0);
            
            var randomGen = new Random();
            var random = randomGen.Range(-this.AttackDamage / 5, this.AttackDamage / 5);
            
            hitbox.HitBoxVariables.Amount = this.AttackDamage + random;
            hitbox.HitBoxVariables.AttackByPlayer = false;
        }
    }
    
    function Shoot()
    {
        
    }
    
    function LookAtPlayer()
    {
        // Look at playerw
        this.Owner.Orientation.LookAtPoint(this.Player.Transform.Translation);
        
        // Make enemy sprite face up
        this.Owner.Children.Current.Orientation.LookAtDirection(Real3(0.0, 1.0, 0.0));
    }
    
    function ChangeSprite()
    {
        // Find the sprite child
        var sprite = this.Owner.Children.Current;
        
        // Get the enemy's direction
        var worldForward = this.Owner.Orientation.WorldForward;
        // Calculate enemy's direction in radians
        var radians = Math.AngleBetween(worldForward, Real3.YAxis);
        // Convert radians to degrees
        var degrees = Math.ToDegrees(radians);
        
        // If enemy's direction is left, Invert degrees
        if (worldForward.X < 0.0)
            degrees *= -1;
        
        // Change sprite (up, upright, right, downrirght, down, downleft, left, upleft)
        if (degrees > -26.5651 && degrees < 26.5651)
            sprite.Sprite.SpriteSource = this.LookUp;
        else if (degrees > 26.5651 && degrees < 63.4349)
            sprite.Sprite.SpriteSource = this.LookUpRight;
        else if (degrees > 63.4349 && degrees < 116.565)
            sprite.Sprite.SpriteSource = this.LookRight;
        else if (degrees > 116.565 && degrees < 153.435)
            sprite.Sprite.SpriteSource = this.LookDownRight;
        else if (degrees > 153.435 || degrees < -153.435)
            sprite.Sprite.SpriteSource = this.LookDown;
        else if (degrees > -153.435 && degrees < -116.565)
            sprite.Sprite.SpriteSource = this.LookDownLeft;
        else if (degrees > -116.565 && degrees < -63.4349)
            sprite.Sprite.SpriteSource = this.LookLeft;
        else if (degrees > -63.4349 && degrees < -26.5651)
            sprite.Sprite.SpriteSource = this.LookUpLeft;
    }
    
    function CheckForPlayer() : Boolean
    {
        //Check for Player
        if (this.Player == null)
            return false;
        else
            return true;
    }
}
